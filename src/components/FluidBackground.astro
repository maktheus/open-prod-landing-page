---
---

<div class="fluid-container" id="canvas-container">
    <canvas id="fluid-canvas"></canvas>
</div>

<style>
    .fluid-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 0;
        pointer-events: auto; /* Required to catch mouse movement */
        background-color: #000;
        overflow: hidden;
    }

    #fluid-canvas {
        width: 100%;
        height: 100%;
        display: block;
    }
</style>

<script>
    import * as THREE from 'three';
    
    // A simplified WebGL fluid simulation for the background
    // Since full Navier-Stokes fluid is extremely complex to write in a single file from scratch,
    // we use a noise-based shader to simulate the "fluid liquid" organic cyber effect that reacts to mouse.
    
    class FluidSimulation {
        private scene: THREE.Scene;
        private camera: THREE.OrthographicCamera;
        private renderer: THREE.WebGLRenderer;
        private material: THREE.ShaderMaterial;
        private mouseInfo: THREE.Vector2;
        private time: number = 0;

        constructor() {
            const container = document.getElementById('canvas-container');
            if(!container) return;

            this.scene = new THREE.Scene();
            
            // Orthographic camera for 2D background
            this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            
            this.renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('fluid-canvas') as HTMLCanvasElement,
                alpha: true,
                antialias: true
            });
            
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            this.mouseInfo = new THREE.Vector2(0.5, 0.5);

            // Shaders for the neon liquid effect
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `;

            const fragmentShader = `
                uniform float u_time;
                uniform vec2 u_resolution;
                uniform vec2 u_mouse;
                varying vec2 vUv;

                // Classic smooth noise
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

                float snoise(vec2 v) {
                    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                                    -0.577350269189626,  // -1.0 + 2.0 * C.x
                                        0.024390243902439); // 1.0 / 41.0
                    vec2 i  = floor(v + dot(v, C.yy) );
                    vec2 x0 = v -   i + dot(i, C.xx);
                    vec2 i1;
                    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                    vec4 x12 = x0.xyxy + C.xxzz;
                    x12.xy -= i1;
                    i = mod289(i); // Avoid truncation effects in permutation
                    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                        + i.x + vec3(0.0, i1.x, 1.0 ));
                    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                    m = m*m ;
                    m = m*m ;
                    vec3 x = 2.0 * fract(p * C.www) - 1.0;
                    vec3 h = abs(x) - 0.5;
                    vec3 ox = floor(x + 0.5);
                    vec3 a0 = x - ox;
                    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
                    vec3 g;
                    g.x  = a0.x  * x0.x  + h.x  * x0.y;
                    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                    return 130.0 * dot(m, g);
                }

                void main() {
                    vec2 st = gl_FragCoord.xy / u_resolution.xy;
                    st.x *= u_resolution.x / u_resolution.y;
                    
                    vec2 mouse = u_mouse;
                    mouse.x *= u_resolution.x / u_resolution.y;

                    // Mouse interaction
                    vec2 dist = st - mouse;
                    float effect = exp(-dot(dist, dist) * 10.0);

                    // Noise domain warping (cyber fluid look)
                    vec2 q = vec2(0.);
                    q.x = snoise(st + 0.00 * u_time);
                    q.y = snoise(st + vec2(1.0));
                    
                    vec2 r = vec2(0.);
                    r.x = snoise(st + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);
                    r.y = snoise(st + 1.0 * q + vec2(8.3, 2.8) + 0.126 * u_time);
                    
                    // Add mouse influence to warping
                    r += dist * effect * 2.5;

                    float f = snoise(st + r);

                    // Colors: Cyberpunk Industrial Amazonian
                    vec3 colorDark = vec3(0.02, 0.02, 0.03); // Bg
                    vec3 colorNeonGreen = vec3(0.22, 1.0, 0.08); // #39ff14
                    vec3 colorMagenta = vec3(1.0, 0.0, 1.0); // #ff00ff

                    // Blend colors based on noise and mouse effect
                    vec3 finalColor = mix(colorDark, colorMagenta, clamp(f * f * 4.0, 0.0, 1.0));
                    finalColor = mix(finalColor, colorNeonGreen, clamp(length(q) * 0.8 + effect * 1.5, 0.0, 1.0));
                    
                    // Industrial vignetting
                    float vignette = 1.0 - length(vUv - 0.5) * 1.2;
                    finalColor *= smoothstep(0.0, 0.5, vignette);

                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;

            this.material = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                uniforms: {
                    u_time: { value: 0 },
                    u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    u_mouse: { value: this.mouseInfo } // Normalized 0..1
                }
            });

            const geometry = new THREE.PlaneGeometry(2, 2);
            const mesh = new THREE.Mesh(geometry, this.material);
            this.scene.add(mesh);

            window.addEventListener('resize', this.onWindowResize.bind(this));
            
            // Mouse tracking
            document.addEventListener('mousemove', (e) => {
                this.mouseInfo.x = e.clientX / window.innerWidth;
                this.mouseInfo.y = 1.0 - (e.clientY / window.innerHeight);
            });

            this.animate();
        }

        private onWindowResize() {
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.material.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
        }

        private animate() {
            requestAnimationFrame(this.animate.bind(this));
            this.time += 0.01;
            this.material.uniforms.u_time.value = this.time;
            this.material.uniforms.u_mouse.value = this.mouseInfo;
            this.renderer.render(this.scene, this.camera);
        }
    }

    // Initialize when DOM is matched
    document.addEventListener('DOMContentLoaded', () => {
        new FluidSimulation();
    });
</script>
